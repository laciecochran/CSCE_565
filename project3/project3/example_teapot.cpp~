//
// Example of drawing a teapot 
// Part of the code was modified from examples in the textbooks
//

#include "Angel.h"
#include "loadModels.h"
 


// the model
vector<vec4> vertices;
vector<GLushort> elements;
vector<vec3> normals;

GLfloat scale_x = 0.3;
GLfloat scale_y = 0.3;
GLfloat scale_z = 0.3;
double shift_x = 0.0;
double shift_y = 0.0;
double theta_x = 0.0;
double theta_y = 0.0;
double theta_z = 0.0;
int old_x = 0;
int old_y = 0;
int valid = 0;
//window width and height
int height = 0;
int width = 0;
//sqrt(width^2 + height^2)
double denom = 0.0;
//constant for pi
#define M_PI 3.1415926535897932384626433832795

GLuint  model_view;  // model-view matrix uniform shader variable location

GLuint  projection; // projection matrix uniform shader variable location


enum { ArrayBuffer, ElementBuffer, NumVertexBuffers };

//
//----------------------------------------------------------------------------

// OpenGL initialization
void
init()
{

    // Create a vertex array object
    GLuint vao;
    glGenVertexArrays( 1, &vao );
    glBindVertexArray( vao );

    // Load a model
    load_obj("../models/teapot.obj", vertices,elements,normals);
if ((vertices.size()==0) || (elements.size()==0)|| (normals.size()==0))
    cout << "Failed to read the model"<<endl;
else
    cout<< vertices.size()<<" "<<elements.size()<<endl;



    // Create and initialize a buffer object
    GLuint buffers[NumVertexBuffers];

    glGenBuffers( NumVertexBuffers, buffers );
    glBindBuffer( GL_ARRAY_BUFFER, buffers[ArrayBuffer] );
    glBufferData( GL_ARRAY_BUFFER, vertices.size()*sizeof(vec4),
		  &vertices[0], GL_STATIC_DRAW );

    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, buffers[ElementBuffer] );
    glBufferData( GL_ELEMENT_ARRAY_BUFFER, elements.size()*sizeof(GLushort), &elements[0], GL_STATIC_DRAW );

    // Load shaders and use the resulting shader program
    GLuint program = InitShader( "vshader_teapot.glsl", "fshader_teapot.glsl" );
    glUseProgram( program );

    // set up vertex arrays
    GLuint vPosition = glGetAttribLocation( program, "vPosition" );
    glEnableVertexAttribArray( vPosition );
    glVertexAttribPointer( vPosition, 4, GL_FLOAT, GL_FALSE, 0,
			   BUFFER_OFFSET(0) );


    model_view = glGetUniformLocation( program, "model_view" );
    projection = glGetUniformLocation( program, "projection" );
    
    glEnable( GL_DEPTH_TEST );
    glClearColor( 1.0, 1.0, 1.0, 1.0 ); 
}

//----------------------------------------------------------------------------

void
display( void )
{
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

     mat4  mv_scale = mat4(scale_x, 0.0, 0.0, 0.0,
        0.0, scale_y, 0.0, 0.0,
        0.0, 0.0, scale_z, 0.0,
        0.0, 0.0, 0.0, 1.0);
     mat4  mv_translate = mat4(1.0, 0.0, 0.0, shift_x,
        0.0, 1.0, 0.0, shift_y,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0);
     mat4  mv_rx = mat4(1.0, 0.0, 0.0, 0.0,
        0.0, cos(theta_x*(M_PI/180)), -sin(theta_x*(M_PI/180)), 0.0,
        0.0, sin(theta_x*(M_PI/180)), cos(theta_x*(M_PI/180)), 0.0,
        0.0, 0.0, 0.0, 1.0);
     mat4  mv_ry = mat4(cos(theta_y*(M_PI/180)), 0.0, sin(theta_y*(M_PI/180)), 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sin(theta_y*(M_PI/180)), 0.0, cos(theta_y*(M_PI/180)), 0.0,
        0.0, 0.0, 0.0, 1.0);
     mat4  mv_rz = mat4(cos(theta_z*(M_PI/180)), -sin(theta_z*(M_PI/180)), 0.0, 0.0,
        sin(theta_z*(M_PI/180)), cos(theta_z*(M_PI/180)), 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0);

    //mv_translate * mv_rz * mv_ry * mv_rx * mv_scale
    glUniformMatrix4fv( model_view, 1, GL_TRUE, mv_translate * mv_rz * mv_ry * mv_rx * mv_scale );

   
    mat4 p = mat4(1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0);
    glUniformMatrix4fv( projection, 1, GL_TRUE, p );

    glDrawElements( GL_TRIANGLES, elements.size()*sizeof(GLushort), GL_UNSIGNED_SHORT, 0);

    glutSwapBuffers();
}

//----------------------------------------------------------------------------

void myMouse(int button, int state, int x, int y)
{
    width = glutGet(GLUT_WINDOW_WIDTH);
    height = glutGet(GLUT_WINDOW_HEIGHT);
    denom = sqrt((height*height)+(width*width));
    if(button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
    {
        //rotate around y-axis
        int dy = old_y - y;
        theta_y += (360*dy)/denom;
    }
    if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
    {
        //rotate around x-axis
        int dx = old_x - x;
        theta_x += (360*dx)/denom;
    }
    if(button == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)
    {
        //rotate around z-axis
        int dx = old_x - x;
        int dy = old_y - y;
        theta_z += (360*dx*dy)/denom;
    }
    old_x = x;
    old_y = y;
    if(state == GLUT_DOWN)
        valid = 1;
    else
        valid = 0;
    glutPostRedisplay();
}

void motion(int x, int y)
{
    if (valid)
    {
        int dx = old_x - x;
        int dy = old_y - y;
        theta_x += (360*dx)/denom;
        theta_y += (360*dy)/denom;
        theta_z += (360*dx*dy)/denom;
    }
    old_x = x;
    old_y = y;
    glutPostRedisplay();
}

//----------------------------------------------------------------------------

void myKey(unsigned char key, int x, int y)
{
    switch (key)
    {
        case 'Q':
        case 'q':
        {
             //exit
             exit (0);
             break;
        }
        case 'H':
        case 'h':
        {
             //initial setting
             scale_x = 0.3;
             scale_y = 0.3;
             scale_z = 0.3;
             shift_x = 0.0;
             shift_y = 0.0;
             theta_x = 0.0;
             theta_y = 0.0;
             theta_z = 0.0;
             glutPostRedisplay();
             break;
        }
        case 'S':
        {
            //Scale up by 10%
            if(scale_x >= -0.1 && scale_x < 1.0 && scale_y >= -0.1 && scale_y < 1.0
                && scale_z >= -0.1 && scale_z < 1.0)
            	scale_x += 0.1;
            	scale_y += 0.1;
            	scale_z += 0.1;
            glutPostRedisplay();
            break;
        }
        case 's':
        {
             //scale down by 10%
             if(scale_x <= 1.0 && scale_x > 0.1 && scale_y <= 1.0 && scale_y > 0.1
                 && scale_z <= 1.0 && scale_z > 0.1)
            	scale_x -= 0.1;
            	scale_y -= 0.1;
            	scale_z -= 0.1;
             glutPostRedisplay();
             break;
        }
        case 'l':
        {
             //shift left along x-axis by -0.1
             shift_x -= 0.1;
             glutPostRedisplay();
             break;
        }
        case 'r':
        {
             //shift right along x-axis by +0.1
             shift_x += 0.1;
             glutPostRedisplay();
             break;
        }
        case 'u':
        {
             //shift up along y-axis by +0.1
             shift_y += 0.1;
             glutPostRedisplay();
             break;
        }
        case 'd':
        {
             //shift down along y-axis by -0.1
             shift_y -= 0.1;
             glutPostRedisplay();
             break;
        }
        //BONUS
        case 'f':
        {
             //return to initial position and flip teapot upside down
             scale_x = -0.3;
             scale_y = 0.3;
             scale_z = 0.3;
             shift_x = 0.0;
             shift_y = 0.0;
             theta_x = 0.0;
             theta_y = 0.0;
             theta_z = 0.0;
             glutPostRedisplay();
             break;
        }
        case 't':
        {
             //return to initial position and turn teapot spout from right to left
             scale_x = -0.3;
             scale_y = 0.3;
             scale_z = 0.3;
             shift_x = 0.0;
             shift_y = 0.0;
             theta_x = 0.0;
             theta_y = 0.0;
             theta_z = 0.0;
             glutPostRedisplay();
             break;
        }
    }
}

//----------------------------------------------------------------------------
int
main( int argc, char **argv )
{
    glutInit( &argc, argv );
    glutInitDisplayMode( GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH );
    glutInitWindowSize( 512, 512 );
    glutInitContextVersion( 3, 2 );
    glutInitContextProfile( GLUT_CORE_PROFILE );
    //First window
    glutCreateWindow( "First Teapot" );
    glewInit();
    init();
    glutDisplayFunc( display );
    //mouse functionality
    glutMouseFunc(myMouse);
    //keyboard functionality
    glutKeyboardFunc(myKey);
  

    //Second Window
    glutCreateWindow( "Second Teapot" );
    init();
    glutDisplayFunc( display );
    //mouse functionality
    glutMouseFunc(myMouse);
    //keyboard functionality
    glutKeyboardFunc(myKey);

    glutMainLoop();
    return 0;
}
